
```{r  Load packages,message=FALSE}
# BiocManager::install(c("limma","GSVA","GSVAdata","org.Hs.eg.db","GSEABase","snow","rlecuyer","edgeR", "gage", "GO.db")) # Comment out this line if you've already installed these packages to your current R distribution.
### Load packages:
library(tidyverse)
library(reshape2)
library(ggthemes)
library(ggpubr)
library(pls)
library(cowplot)
library(plotly)
library(RColorBrewer)
library(colorspace)
library(jcolors)
library(ggsci)
library(cowplot)
library(Hmisc)
library(NMF)
library(stats)
library(NMF)
library(ggfortify)
library(ggrepel)
library(GSVA) # Gene set variation analysis package from Bioconductor --> This package contains a command that can perform four types of gene set enrichment analyses: GSVA, ssGSEA, PLAGE, and z-score.
library(org.Hs.eg.db)
library(GSVAdata)
library(GSEABase)
library(limma)
library(msigdbr)
library(gage)
library(plyr)
library(GO.db)
library(heatmaply)
library(plsVarSel)
```

```{r Clear environment}
### Clear R workspace:
rm(list=ls())
```

```{r Check and set working directory}
### Check current working directory:
cwd <- getwd()
cwd
### Set working directory:
setwd(cwd) # Set current working directory to location of this notebook for easier handling and saving of data associated with the notebook
```

# Load CCLE RNA-seq Data
We now load RNA-seq data from the Cancer Cell Line Encyclopedia (CCLE). (See https://depmap.org/portal/download/ and download the file "CCLE_expression.csv".) We are only interested in using the RNA-seq data for protein coding genes. Other data from the CCLE, including the CCLE's RPPA data and information on all of the cell lines in the CCLE (required for the code below) are also available for download from this portal. These data are supplied as log2-transformed, 1-shifted RSEM TPM values, denoted below as $x_{i,j}^{log}$:

$$x_{i,j}^{log}=log_2(TPM_{i,j}+1)$$
We'll start by first loading the information on all 26 triple-negative breast cancer (TNBC) cell lines that are in the CCLE and then loading the TNBC RNA-seq data itself.
```{r Load PARADIGM GBM data}
## Load pathway information for 149 GBM samples
paradigm <- "GBM_merge_merged_reals.txt"
ipls <- read_tsv(paradigm)
ipls <- column_to_rownames(ipls, var="sample")
ipls <- t(ipls)
ipls <- rownames_to_column(as.data.frame(ipls), var="sample")
ipls.programs <- names(ipls)[which(map_dbl(ipls, var)>1)] ##filtering out genes w/ variance <1 among samples 
ipls <- dplyr::select(ipls, c("sample", ipls.programs))

#summary(ipls)

```

```{r Load RPPA GBM data}
## Load RPPA data for 215 GBM samples
rppa.path <- "RPPA_RBN.txt"
rppa <- read_tsv(rppa.path)
rppa <- column_to_rownames(rppa, var="Sample_description")
rppa <- t(rppa)
rppa <- rownames_to_column(as.data.frame(rppa), var="sample")

```
```{r clean up RPPA and PARADIGM data}
#ipls <- semi_join(ipls, rppa, by="sample")
#rppa <- semi_join(rppa, ipls, by="sample")

subtype.info <- "gbm_tcga_pub2013_clinical_data.tsv"
subtype <- read_tsv(subtype.info)
subtype <- dplyr::rename(subtype, `sample`=`Sample ID`)
subtype <- semi_join(subtype, rppa, by="sample")
#rppa <- semi_join(rppa, subtype, by="sample")
#ipls <- column_to_rownames(ipls, var="sample")
#ipls <- as.data.frame(ipls %>% scale(center=TRUE, scale=TRUE))
#subtype <- column_to_rownames(subtype, var="sample")
rppa <- column_to_rownames(rppa, var="sample")
#rppa <- rppa %>% add_column(subtype$`Overall Survival (Months)`)
#rppa <- dplyr::rename(rppa, survival = 'subtype$`Overall Survival (Months)`')
#rppa$survival <- rppa$survival %>% scale(center=T, scale=T)

rppa.select <- rppa %>% dplyr::select(
                        contains("4EBP1"),
                        contains("AKT"),
                        contains("BETACATENIN"),
                        contains("CJUN"),
                        contains("CMET"),
                        contains("CMYC"),
                        contains("COLLAGEN"),
                        contains("CRAF"),
                        contains("EGFR"),
                        contains("CYCLIN"),
                        contains("FIBRONECTIN"),
                        contains("JNK"),
                        contains("MEK1"),
                        contains("MTOR"),
                        contains("NCADHERIN"),
                        contains("NFKB"),
                        contains("NOTCH"),
                        contains("P38"),
                        contains("PKC"),
                        contains("PTEN"),
                        contains("SMAD"),
                        contains("SRC"),
                        contains("STAT"),
                        contains("PAI1"),
                        contains("YAP"),
                        contains("VEGFR"))
                        #contains("survival"))

#aheatmap(ipls, breaks=c(0), revC=T)
#aheatmap(rppa, breaks=c(0), revC=T)
heatmaply(rppa)
```

```{r analysis}
cor.proteins.rppa <- cor(rppa)
cor.samples.rppa <- cor(t(rppa))
heatmaply(cor.proteins.rppa)
heatmaply(cor.samples.rppa)
#aheatmap(cor.samples.rppa,breaks=c(0),revC=T)
#aheatmap(cor.proteins.rppa,breaks=c(0),revC=T)

#cor.pathways.ipls <- cor(ipls)
#cor.samples.ipls <- cor(t(ipls))
#aheatmap(cor.samples.ipls,breaks=c(0),revC=T)
#aheatmap(cor.pathways.ipls,breaks=c(0),revC=T)

#cov.data <- cov(rppa, ipls)
#aheatmap(cov.data,breaks=c(0),revC=T)

```

```{r PCA of RPPA data}
proteins <- colnames(rppa)
pcamat <- t(rppa)
pcadat <- prcomp(pcamat,center=F,scale=F,retx=T)
# pcamat is the matrix that contains z scores
# the transform is take here to have samples as rows and msmts as columns
# center is a logical value indicating whether the variables should be shifted or zero centered
# scale is a logical value indicating whether the variables should be scaled to have unit variance
# retx is a logical value indicating whether the rotated variables should be returned
# scores
sc <- pcadat$x
#loadings
ld <- pcadat$rotation
# scree plot and variance capture
#screeplot(pcadat)
eigVals = (pcadat$sdev)^2
varExp <- eigVals*100/sum(eigVals)
# scores and loadings biplot
#biplot(pcadat)
autoplot(pcadat, loadings=F, loadings.label=F, loadings.label.size=5)+
  theme_classic()+
  geom_text_repel(size=3, label = proteins)
```
```{r RPPA PLSR}
#rppa.prot <- rppa.select
rppa.prot <- rppa
#rppa.prot <- dplyr::select(rppa.prot, -"survival")
rppa.prot <- rppa.prot %>% scale(center=T, scale=T) %>% as.data.frame()
proteins.y <- c( "FIBRONECTIN", "PAI1", "COLLAGENVI")
Y <- data.matrix(dplyr::select(rppa.prot, proteins.y))
X <- data.matrix(dplyr::select(rppa.prot, -proteins.y))
'
#install.packages("plsVarSel")
library("plsVarSel")
#using bve_pls to run pls and remove columns in X with low predictive value
thr <- 1
cols <- intersect(
  bve_pls(Y[,1], X, VIP.threshold = thr)$bve.selection,
  bve_pls(Y[,2], X, VIP.threshold = thr)$bve.selection %>%
    intersect(bve_pls(Y[,3], X, VIP.threshold = thr)$bve.selection)
)
cols.x <- colnames(X)
pr.x <- c()
for (i in cols) {
  pr.x <- append(pr.x, cols.x[i])
}
X <- data.matrix(dplyr::select(rppa.prot, pr.x))
'
#run PLSR
mydata <- data.frame(yy=I(Y),xx=I(X))
PLSR_matrix <- plsr(yy~xx, scale=F, data=mydata, method="kernelpls")
#summary(PLSR_matrix)

#filtering points based on VIP scores
score.min <- 1
vip.scores <- VIP(PLSR_matrix, 3) %>% data.frame()
colnames(vip.scores)[1] <- "VIP.score"
vip.scores <- rownames_to_column(vip.scores, var="protein")
vip.scores <- vip.scores %>% filter(VIP.score>score.min)
proteins.VIP <- vip.scores$protein
#running PLSR again using only proteins w/ high VIP scores

X <- data.matrix(dplyr::select(rppa.prot, proteins.VIP))
mydata <- data.frame(yy=I(Y),xx=I(X))
PLSR_matrix <- plsr(yy~xx, scale=F, data=mydata, method="kernelpls")
plot(PLSR_matrix, plottype = "scores")
sc <- scores(PLSR_matrix)
ld <- loadings(PLSR_matrix)
Ysc <-Yscores(PLSR_matrix)
Yld <- Yloadings(PLSR_matrix)
vip.scores <- vip.scores %>% cbind(ld[,1])
colnames(vip.scores)[ncol(vip.scores)] <- "PC1"
ld <- cbind(ld, vip.scores$VIP.score)

ggplot(data=arrange(vip.scores, desc(VIP.score)), 
       aes(x=reorder(protein, -VIP.score), y=VIP.score, fill=PC1))+
  geom_bar(stat="identity")+
    theme_cowplot()+
  theme(axis.text.x=element_text(angle=90, vjust=.5, hjust=1),
        panel.background = element_rect(color = "#000000")
        )+
  scale_fill_gradient2( # Custom color gradient for bars
    midpoint=0,
    low="red",
    mid="#555555",
    high="blue",
    aesthetics="fill"
  ) +
  labs(title = paste0("VIP Scores > ", score.min),
       x = element_blank(),
       y = "VIP score")

ggplot()+
  geom_hline(yintercept = 0, color = "#333333", linetype = "dashed", alpha = 0.7) +
  geom_vline(xintercept = 0, color = "#333333", linetype = "dashed", alpha = 0.7) +
  geom_point(aes(x=ld[,1], y=ld[,2], size = (ld[,ncol(ld)]-min(ld[,ncol(ld)]))/max(ld[,ncol(ld)])), alpha=0.5)+
  geom_point(aes(x=Yld[,1], y=Yld[,2]), color="blue")+
  labs(title="GBM TCGA RPPA PLSR", 
       x=paste0("PC1", " (",explvar(PLSR_matrix)[1]%>%round(1), "%)"), 
       y=paste0("PC2", " (",explvar(PLSR_matrix)[2]%>%round(1), "%)"))+
  geom_text_repel(aes(x=ld[,1], y=ld[,2]), 
                  label=rownames(ld),
                  color="#555555",
                  size=3)+
  geom_text_repel(aes(x=Yld[,1], y=Yld[,2]), 
            label=rownames(Yld), size=3, color="blue")+
  theme_cowplot() +
  scale_size(
    limits=c(0,1),
  )+
  theme(
    panel.background = element_rect(color = "#000000"),
    legend.position = "none"
  ) +
  scale_x_continuous(expand=expansion(mult=.1))


#rppa.cov <- cov(Y, X)
#heatmaply(
#  rppa.cov,
#  cexCol = 0.5
#  )
#write.table(sc, file="RPPAscores.txt",col.names=T,row.names=T,sep="\t", quote=F)
#write.table(ld, file="RPPAloadings.txt",col.names=T,row.names=T,sep="\t", quote=F)
#write.table(Ysc, file="RPPAYscores.txt",col.names=T,row.names=T,sep="\t", quote=F)
#write.table(Yld, file="RPPAYloadings.txt",col.names=T,row.names=T,sep="\t", quote=F)
```
```{r TCGA RNA-seq PLSR}
#input list of genes of interest: 33 genes from "A multigene predictor of outcome in glioblastoma" Aldape, 2010
#genes.y <- c("ACTN1", "AQP1", "CHI3L1", "CLIC1", "COL1A2", "EMP3", "FABP5", "FN1", "GABBR1", "GPNMB", "GRIA2", "IGFBP2", "IGFBP3", "LDHA", "LGALS1", "LGALS3", "MAOB", "NNMT", "OLIG2", "OMG", "PDPN", "PLP2", "RTN1", "S100A10", "SERPINE1", "SERPING1", "TAGLN", "TAGLN2", "TCF12","TGFBI", "TIMP1", "TMSB10", "TNC")
#genes.y.surv <- c(1, 1, 1, 1, 1, 1, 1, 1, -1, 1, -1, 1, 1, 1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 1, -1,1, 1, 1, 1)
genes.y <- rbind(
#  c("AQP1", 1),
#  c("CHI3L1", 1),
#  c("EMP3", 1),
#  c("GPNMB", 1),
#  c("IGFBP2", 1),
#  c("LGALS3", 1),
#  c("OLIG2", -1),
#  c("PDPN", 1),
#  c("RTN1", -1)
  c("FN1", 1),
  c("DLL3", -1),
  c("SOX2", -1),
  c("ERBB3", -1),
  c("OLIG2", -1),
  c("CHI3L1", 1),
  c("TRADD", 1), 
  c("TLR2", 1),
  c("RELB", 1)
#  c("FGFR3", 0),
#  c("PDGFA", 0),
#  c("EGFR", 0),
#  c("AKT2", 0),
#  c("NES", 0)
)
colnames(genes.y) <- c("gene", "survival")
genes.y.surv <- genes.y[,2] %>% as.numeric()

rna.path <- "HiSeqV2.txt"
rna <- read_tsv(rna.path)
rna <- column_to_rownames(rna, var="sample")
rna <- t(rna)
rna <- as.data.frame(rna)
rna <- rna %>% scale(center=T, scale=T) %>% data.frame()
rna <- rna %>% select_if(~ !any(is.na(.)))
rna.samples <- rownames(rna)

Y <- data.matrix(dplyr::select(rna, genes.y[,1]))
X <- dplyr::select(rna, -genes.y[,1]) %>% data.matrix()

mydata <- data.frame(yy=I(Y),xx=I(X))
PLSR_matrix <- plsr(yy~xx, scale=F, data=mydata, method="kernelpls")
#summary(PLSR_matrix)

#filtering points based on VIP scores
score.min <- 1.8
vip.scores <- VIP(PLSR_matrix, 5) %>% data.frame()
colnames(vip.scores)[1] <- "VIP.score"
vip.scores <- rownames_to_column(vip.scores, var="protein")
vip.scores <- vip.scores %>% filter(VIP.score>score.min)
proteins.VIP <- vip.scores$protein
#running PLSR again using only proteins w/ high VIP scores

X <- data.matrix(dplyr::select(rna, proteins.VIP))
mydata <- data.frame(yy=I(Y),xx=I(X))
PLSR_matrix <- plsr(yy~xx, scale=F, data=mydata, method="kernelpls")
plot(PLSR_matrix, plottype = "scores")
sc <- scores(PLSR_matrix)
ld <- loadings(PLSR_matrix)
Ysc <-Yscores(PLSR_matrix)
Yld <- Yloadings(PLSR_matrix)

Yld <- cbind(Yld, genes.y.surv)
ld <- cbind(ld, vip.scores$VIP.score)
colnames(ld)[ncol(ld)] <- "VIP.score"

vip.scores <- vip.scores %>% cbind(ld[,1])
colnames(vip.scores)[ncol(vip.scores)] <- "PC1"

ggplot(data=arrange(vip.scores, desc(VIP.score)), 
       aes(x=reorder(protein, -VIP.score), y=VIP.score, fill=PC1))+
  geom_bar(stat="identity")+
  theme_cowplot()+
    theme(axis.text.x=element_text(angle=90, vjust=.5, hjust=1),
        panel.background = element_rect(color = "#000000")
        )+
  scale_fill_gradient2( # Custom color gradient for bars
    midpoint=0,
    low="red",
    mid="#555555",
    high="blue",
    aesthetics="fill"
  ) +
  labs(title = paste0("VIP Scores > ", score.min),
       x = element_blank(),
       y = "VIP score")

ggplot()+
  geom_hline(yintercept = 0, color = "#333333", linetype = "dashed", alpha = 0.7) +
  geom_vline(xintercept = 0, color = "#333333", linetype = "dashed", alpha = 0.7) +
  geom_point(aes(x=ld[,1], y=ld[,2], size=((ld[,ncol(ld)]-min(ld[,ncol(ld)]))/max(ld[,ncol(ld)]))), alpha=0.5)+
  geom_point(aes(x=Yld[,1], y=Yld[,2], color=genes.y.surv))+
  labs(title="GBM TCGA RNA-seq PLSR", 
       x=paste0("PC1", " (",explvar(PLSR_matrix)[1]%>%round(1), "%)"), 
       y=paste0("PC2", " (",explvar(PLSR_matrix)[2]%>%round(1), "%)"))+
  geom_text_repel(aes(x=ld[,1], y=ld[,2]), 
                  label=rownames(ld),
                  size=3)+
  geom_text_repel(aes(x=Yld[,1], y=Yld[,2], color=genes.y.surv), 
            label=rownames(Yld), 
            size=3)+
  scale_color_gradient2( # Custom color gradient for bars
    limits = c(-1,1),
    midpoint=0,
    high="#0033ff",
    mid="#8f00ff",
    low="#ff3300"
  ) +
  scale_size(
    limits=c(0,1),
  )+
  theme_cowplot() +
  theme(
    panel.background = element_rect(color = "#000000"),
    legend.position = "none"
  ) +
  scale_x_continuous(expand=expansion(mult=.05))


rppa.cov <- cov(Y, X)
heatmaply(
  rppa.cov,
  cexCol = 0.5
  )

```


```{r PCA of pathway data}
pathways <- colnames(ipls)
pcamat <- t(ipls)
pcadat <- prcomp(pcamat,center=T,scale=T,retx=T)
sc <- pcadat$x
#loadings
ld <- pcadat$rotation
# scree plot and variance capture
#screeplot(pcadat)
eigVals = (pcadat$sdev)^2
varExp <- eigVals*100/sum(eigVals)
# scores and loadings biplot
#(pcadat)
autoplot(pcadat, loadings=F, loadings.label=F, loadings.label.size=5)+
  theme_classic()+
  geom_text_repel(size=2, label = pathways)
```

```{r RPPA - PARADIGM PLSR}
X <- data.matrix((ipls))
y <- data.matrix((rppa))
mydata <- data.frame(yy=I(y),xx=I(X))
PLSR_matrix <- plsr(yy~xx, scale=F, data=mydata, method="kernelpls")
#summary(PLSR_matrix)
plot(PLSR_matrix, plottype = "scores", comp=1:3)
sc <- scores(PLSR_matrix)
ld <- loadings(PLSR_matrix)
Ysc <-Yscores(PLSR_matrix)
Yld <- Yloadings(PLSR_matrix)

#write.table(sc, file="scores.txt",col.names=T,row.names=T,sep="\t", quote=F)
#write.table(ld, file="loadings.txt",col.names=T,row.names=T,sep="\t", quote=F)
#write.table(Ysc, file="Yscores.txt",col.names=T,row.names=T,sep="\t", quote=F)
#write.table(Yld, file="Yloadings.txt",col.names=T,row.names=T,sep="\t", quote=F)
```

```{r Load CCLE cell line info, warning=FALSE}
##### Load cell line info:
## Path for cell line info:
fn.cells <- "CCLE_sample_info.csv"

## Load info for TNBC cell lines:
cl.sum <- read.csv(fn.cells)   #Cell line summaries
cl.id <- cl.sum$DepMap_ID %>% as.character()  #DepMap IDs for cell lines
cl.name <- cl.sum$stripped_cell_line_name %>% as.character()  #Cell line names
ccle.names <- cl.sum$CCLE_Name %>% as.character() #CCLE cell line names

# Desired TNBC cell lines:
tcl.names <- c("BT20","BT549","CAL120","CAL148","CAL51","CAL851","DU4475","HCC1143","HCC1187",
               "HCC1395","HCC1500","HCC1599","HCC1806","HCC1937","HCC2157","HCC38","HCC70","HDQP1",
               "HMEL","HS274T","HS578T","MDAMB157","MDAMB231","MDAMB436","MDAMB453","MDAMB468","SUM159PT") 

tcl.ind <- which(cl.name %in% tcl.names) #Indices of TNBC lines in full list of cell lines

## Extract TNBC cell line names:
tcl.id <- cl.id[tcl.ind] #TNBC cell line DepMap IDs...
tcl.name <- cl.name[tcl.ind] %>% as.character() #...and the full cell line names in the same order.
tcl.ccle.names <- ccle.names[tcl.ind] # CCLE names for TNBC lines
```

And now load the CCLE RNA-seq data.
```{r Load RNA-seq data}
rna.path <- "HiSeqV2.txt"
rna <- read_tsv(rna.path)
rna <- column_to_rownames(rna, var="sample")
rna <- t(rna)
rna <- as.data.frame(rna)
rna <- rownames_to_column(rna, var="sample")
rna.samples <- rna$sample

subtype.info <- "gbm_tcga_pub2013_clinical_data.tsv"
subtype <- read_tsv(subtype.info)
subtype <- dplyr::rename(subtype, `sample`=`Sample ID`)
subtype <- filter(subtype, `Gene Expression Subtype`!="NA")
subtype <- semi_join(subtype, rna, by="sample")
rna <- semi_join(rna, subtype, by="sample")
rna <- add_column(rna, subtype$`Gene Expression Subtype`)
rna <- dplyr::rename(rna, subtype = 'subtype$`Gene Expression Subtype`')
rna <- mutate(rna, sample=paste(sample,subtype))
rna <- subset(rna, select = -subtype)
rna <- column_to_rownames(remove_rownames(rna), var="sample")
```

```{r Load CCLE RNA-seq data, warning=FALSE}
##### Load CCLE RNA-seq data: log2(TPM+1) values
## File path for CCLE RNA-seq data:
fn4 = "CCLE_RNAseq_gene_expression_TPM_log2.csv"

## Load CCLE RNA-seq data:
ccle.rna <- read_csv(fn4, col_names=T)
ccle.genes <- colnames(ccle.rna)[-1] %>%
  gsub("\\ .*","",.) # Remove extraneous suffixes on gene names
colnames(ccle.rna) <- c("Cell.line", ccle.genes)

## Get TNBC cell line data:
ccle.id.rna <- ccle.rna$Cell.line %>% as.character() # Get DepMap IDs from CCLE data

# Pull out the TNBC IDs, names, and data:
tcl.ind.ccle.rna <- which(ccle.id.rna %in% tcl.id) # Match TNBC cell line DepMap IDs to DepMap IDs in data set
tcl.id.ccle.rna <- ccle.id.rna[tcl.ind.ccle.rna] # DepMap IDs in data set
tcl.name.ccle.rna <- match(tcl.id.ccle.rna, tcl.id) %>%
  tcl.name[.] # Names

# Pull out the TNBC data:
tcl.ccle.rna <- ccle.rna[tcl.ind.ccle.rna,] # mRNA expression

tcl.ccle.rna$Cell.line <- tcl.name.ccle.rna # Replace DepMap IDs with stripped cell line names
```

### RPPA Data
Reverse-phase protein array (RPPA) data from the CCLE can also be obtained from either the primary CCLE website or from the DepMap Portal.

```{r Load CCLE RPPA data}
##### Load CCLE RPPA data: 
## File path for CCLE RPPA data:
fn5 = "CCLE_RPPA_20181003.csv"

## Load CCLE RPPA data:
ccle.rppa <- read_csv(fn5, col_names=T)
ccle.ans <- colnames(ccle.rppa)[-1] %>% 
  gsub("\\_Caution.*","",.) # Remove extraneous "_Caution" suffixes on analyte names
colnames(ccle.rppa) <- c("Cell.line", ccle.ans)


## Get TNBC cell line data:
ccle.names.rppa <- ccle.rppa$Cell.line %>% as.character() # Get CCLE names from CCLE RPPA data

# Pull out the TNBC IDs, names, and data:
tcl.ind.ccle.rppa <- which(ccle.names.rppa %in% tcl.ccle.names) # Match TNBC cell line DepMap IDs to DepMap IDs in data set
tcl.names.ccle.rppa <- ccle.names.rppa[tcl.ind.ccle.rppa] %>% 
  gsub("\\_.*","",.) # Cleaned (stripped) CCLE cell line names


# Pull out the TNBC data:
tcl.ccle.rppa <- ccle.rppa[tcl.ind.ccle.rppa,] # Data

tcl.ccle.rppa$Cell.line <- tcl.names.ccle.rppa # Replace DepMap IDs with stripped cell line names

## Explore the data with ggplot:
ggplot(data = tcl.ccle.rppa) + 
  geom_col(
    fill="#FF6666", # Manually set fill (color) of bars
    color="black", # Bar outline color
    aes(
      x=Cell.line,
      y=EGFR # Select analyte to visualize
      )
    ) +
  geom_hline(yintercept=0)+
  theme_cowplot()+
  theme(
    axis.text.x=element_text(
      angle=45,
      hjust=1
      )
    ) +
  labs(x="Cell line",
       title="CCLE RPPA Data")
```

## MCLP RPPA Data
RPPA data can also be obtained from the MD Anderson Cell Lines Project (MCLP). These data are available at https://tcpaportal.org/mclp/#/download. 

```{r Load MCLP RPPA data}
##### Load MCLP RPPA data: 
## File path for MCLP RPPA data:
fn6 = "MCLP-v1.1-Level4.tsv"

## Load MCLP RPPA data:
mclp.rppa <- read_tsv(fn6, col_names=T)
mclp.ans <- colnames(mclp.rppa)[-1] 
colnames(mclp.rppa)[1] <- "Cell.line"


## Get TNBC cell line data:
mclp.names.rppa <- mclp.rppa$Cell.line %>% as.character() # Get MCLP names from MCLP RPPA data

# Pull out the TNBC IDs, names, and data:
tcl.ind.mclp.rppa <- which(mclp.names.rppa %in% tcl.names) # Match TNBC cell line names in data set
tcl.names.mclp.rppa <- mclp.names.rppa[tcl.ind.mclp.rppa] %>% 
  gsub("\\_.*","",.) # MCLP cell line names


# Pull out the TNBC data:
tcl.mclp.rppa <- mclp.rppa[tcl.ind.mclp.rppa,] # Data

## Explore the data with ggplot:
ggplot(data = tcl.mclp.rppa) + 
  geom_col(
    fill="#FF6666", # Manually set fill (color) of bars
    color="black", # Bar outline color
    aes(
      x=Cell.line,
      y=EGFR # Select analyte to visualize
      )
    ) +
  geom_hline(yintercept=0)+
  theme_cowplot()+
  theme(
    axis.text.x=element_text(angle=45,
                             hjust=1)) +
  labs(x="Cell line",
       title="MCLP RPPA Data")
```

## TCGA RNA-seq and RPPA Data
### RNA-seq Data
RNA-seq data from The Cancer Genome Atlas (TCGA) can be obtained in multiple ways from multiple sources. The data used below, which only contains RNA-seq data for TCGA samples identified pathologically as triple-negative breast cancer, were originally obtained by the lab of Kevin A. James and were supplied as unnormalized RSEM values. The easiest way to obtain TCGA data is through the UCSC Xena portal at https://xena.ucsc.edu/public/ and https://xenabrowser.net/. The Xena portal also provides access to additional tissue sample and cell line repositories (including the CCLE) besides TCGA alone.

Below, we load TCGA RNA-seq data from TNBC tissue samples and normalize the RSEM values as described above for the CCLE RNA-seq data.
```{r Load TCGA TNBC RNA-seq data}
##### Load TCGA TNBC RNA-seq data (obtained from Kevin Janes as unnormalized RSEM values and already selected as TN based on pathology): 
## File path for TCGA data:
fn7 = "TCGA_TNBC_RNAseq.txt"

## Load TCGA data:
tcga <- read_tsv(fn7, col_names=T)

tcga$Gene_ID <- tcga$Gene_ID %>% # Get gene names
  gsub("\\|.*","",.) # Remove extraneous gene name suffixes


tcga.tnbc.samps <- colnames(tcga)[-1] # Store original TCGA TNBC sample names
tcga.samps <- tcga.tnbc.samps %>% # Get sample names to clean them up (for readability on plots)
  gsub("\\TCGA-*|\\-01*","",.) #Remove extraneous text from names

tcga <- tcga[!tcga$Gene_ID=="?",]  # Remove "?" genes

tcga.genes <- tcga$Gene_ID # Get gene names

## Need to transpose matrix and normalize RSEM values as TPM (transcripts per million):
tcga.1 <- tcga[,-1] %>% # Get just numeric entries (ignore Gene_ID)
  data.matrix() %>% # Convert to numeric matrix
  scale(center=F, scale=colSums(.)) %>% # Divide columns by sums
  multiply_by(1.0e6) %>% # Multiply by one million (now have TPM)
  t() %>%  # Transpose
  add(1) %>% # Shift by 1 (for taking log-transform of zero values)
  log2() %>%  # log2 transform
  data.frame() # Convert back to data frame
  
colnames(tcga.1) <- tcga.genes # Rename columns w/ gene names
tcga.2 <- tcga.1 %>% data.frame(tcga.samps, .) # Append sample names as a variable
colnames(tcga.2)[1] <- "Sample" # Rename sample column


##### Explore data with ggplot:
##### Plot mRNA expression ##### 
#### Column plot RNA expression
ggplot(data = tcga.2) + 
  geom_col(
    fill="#FF6666", # Manually set fill (color) of bars
    color="black", # Bar outline color
    aes(
      x=Sample,
      y=BCAR3 # Select analyte to visualize
      )
    ) +
  theme_cowplot()+
  # theme_base()+
  scale_y_continuous(
    # don't expand y scale at the lower end
    expand = expand_scale(mult = c(0, 0.05))
  ) +  
  theme(
    axis.text.x=element_text(
      size=10, # Size of X tick labels
      angle=90, # Angle of X tick labels
      vjust=0.4
      )
    ) + # Adjust X tick horizontal positions
  labs(fill="Gene",
       x="Cell line",
       title=expression(paste("TCGA RNA-seq: ", log[2],"(TPM+1)")))
##### Two-gene scatterplot #####
#### Scatter plot of two genes with simple linear model line and confidence intervals
ggplot(data=tcga.2, 
       aes(
         x=EGFR,
         y=BCAR3)
       )+
  geom_smooth(method="lm")+
  geom_point()+ # 2D scatter plot
  # geom_label(
  #   aes(
  #   label=Sample
  #   ), # Add sample names to plot (if desired)
  #   nudge_y=0.2,
  #   size = 3
  #   )+
  theme_cowplot()+
  theme(
    axis.text.x=element_text(
      size=11, # Size of X tick labels
      # angle=90, # Angle of X tick labels
      vjust=0.4
      )
    ) + # Adjust X tick horizontal positions
  labs(
    fill="Gene",
    title=expression(paste("TCGA RNA-seq: ", log[2],"(TPM+1)"))
    )


## Remove extraneous variables from memory, if desired:
rm(tcga, tcga.1)
```
### RPPA Data
Load the TCGA BRCA RPPA data (obtained from UCSC Xena portal). For consistency's sake with the MCLP data, we're going to use the "replicate-based normalization" (RBN) data.
```{r Load TCGA BRCA RPPA data}
## File path for data:
fn8 <- "TCGA_BRCA_RPPA_RBN.tsv"
## Load file:
brca.tcga.rppa <- read_tsv(fn8, col_names = T)
## Store sample names and extract names of known TNBC TCGA samples:
match.tcga.samps <- colnames(brca.tcga.rppa) %>% # Get RPPA sample names
  match(tcga.tnbc.samps) %>% # Match RPPA samples to TNBC RNA-seq samples
  tcga.tnbc.samps[.] %>% # Get TN RPPA sample names 
  na.omit() # Remove non-TN samples
# view(match.tcga.samps)
## Clean the sample names:
tcga.rppa.samps <- match.tcga.samps %>% # Get sample names to clean them up (for readability on plots)
  gsub("\\TCGA-*|\\-01*","",.) # Remove extraneous text from names

## Get TNBC sample RPPA data:
tcl.tcga.rppa <- brca.tcga.rppa[,match.tcga.samps] %>% 
  data.matrix() %>% # Convert to numeric
  t() %>% # Transpose
  data.table(Sample=tcga.rppa.samps, .) # Convert to data.table (more efficient data.frame)
colnames(tcl.tcga.rppa)[-1] <- brca.tcga.rppa$Sample_description # Add analyte (column/variable) names

##### Explore data with ggplot:
##### Heatmap of RPPA scores #####
## Melt data to long format:
tcl.tcga.rppa.l <- tcl.tcga.rppa %>%
  melt(id.vars="Sample")

## Plot as a heatmap:
ggplot(data=tcl.tcga.rppa.l) +
  geom_tile( # Use tile geom --> basically a heatmap
    # linetype="dashed", # Type of lines between tiles
    # color="#000000", # Color of lines between tiles
    aes(
      fill=value,
      x=variable,
      y=Sample
    )
  )+
  # scale_fill_viridis_c(
  #   limits = c(-max(tcl.tcga.rppa.l$value),max(tcl.tcga.rppa.l$value))
  #   )+ # Viridis color scheme
  scale_fill_gradient2( # Custom color gradient for bars
    limits = c(-max(tcl.tcga.rppa.l$value),max(tcl.tcga.rppa.l$value)),
    midpoint=0,
    low="#003366",
    mid="#CCCCCC",
    high="red",
    space ="Lab"
    ) +
  theme_cowplot(
    ) +
  theme(
    axis.text.x=element_text(
      size = 10,  # X tick mark TEXT SIZE
      angle = 90, # X tick mark ANGLE
      hjust = 1, # Shift horizontal position of X tick marks
      vjust = 0.4 # Shift vertical position of X tick marks
    )
  ) +
  scale_y_discrete(
    # don't expand y scale at the lower end
    expand = expand_scale(mult = c(0, 0))
  ) +
  labs(
    title="TCGA TNBC RPPA",
    x="Analyte",
    y="Sample",
    fill="RPPA score"
  ) + 
  guides(
    # fill=FALSE
  )
```

## GSVA: CCLE RNA-seq Data
### mRNA Expression Data
Here, we'll use the technique known as gene set variation analysis (GSVA) to analyze the molecular/cellular signaling pathways that are up- and down-regulated in each of the TNBC cell lines of interest. GSVA is closely related to single-sample gene set enrichment analysis (ssGSEA). The GSVA package we'll use below actually includes an option for running ssGSEA in the main command for the analysis, if it's desired.

The description for the GSVA R package can be found [here](https://www.bioconductor.org/packages/release/bioc/html/GSVA.html). 
```{r GSVA: CCLE RNA-seq data, warning=FALSE, message=FALSE}
### Install packages if not done already:
# BiocManager::install(c("limma","GSVA","GSVAdata","org.Hs.eg.db","GSEABase","snow","rlecuyer","edgeR")) # Comment out this line if you've already installed these packages to your current R distribution.

### Load packages:
library(GSVA) # Gene set variation analysis package from Bioconductor --> This package contains a command that can perform four types of gene set enrichment analyses: GSVA, ssGSEA, PLAGE, and z-score.
library(GSVAdata)
library(org.Hs.eg.db)
library(GSEABase)
library(limma)
library(msigdbr)

### Start by putting data in .GCT format:
data_for_gsva <- rna %>% as.matrix() %>% t() %>% .[-1,]


## Convert gene names to Entrez IDs:
entrez_ids <- rownames(data_for_gsva) %>% mapIds(org.Hs.eg.db, ., 'ENTREZID', 'SYMBOL')
rownames(data_for_gsva) <- entrez_ids

### Define MSigDB gene set collection to use:
gene_sets <- getGmt("msigdb.v7.0.entrez.gmt") %>% # Load all GSEA/Broad MSigDB gene sets
  .[grep("^HALLMARK|^KEGG|^CELL_|^REACTOME_SIGNALING_BY|^PID_", names(.))] # Pull curated gene sets by their database/primary identifier

### GO gene sets:
library(gage) # Install using Bioconductor if you don't have it

### Select subset of gene sets to analyze using keywords in their names:
## Gene set keywords:
## Use GO gene sets or MSigDB gene sets?
gene_set_choice <- "MSigDB" # Define this as either "GO" or something completely different (like "MSigDB") --> if "GO" is not used, then key words for MSigDB gene sets will be chosen automatically for the GSVA analysis below

### Load desired gene set(s) and perform GSVA:
if(gene_set_choice == "GO"){
  ### Calculate GSVA enrichment scores:
  tn.gsva <- gsva(
    data_for_gsva, 
    go.gsets()[["go.sets"]], 
    method="gsva", 
    parallel.sz=detectCores()-1
    )
  tn.gsva.df <- tn.gsva %>% data.frame(gene.set=rownames(.), .) # Convert to data frame
  rm(tn.gsva) # Remove matrix form from environment
  
} else {
  ## Select key words to further subset the selected MSigDB gene set collection:
  gs.kw <- c(
    # "REACTOME",
    # "BREAST",
    #"RECEPTOR_TYROSINE",
    #"BY_EGFR",
    #"BY_ERBB2",
    #"BY_ERBB4",
    #"PID_ERBB2_ERBB3",
    #"PID_ERBB_NETWORK",
    #"PID_ECADHERIN_STAB",
    #"PID_TGBFR",
    #"BY_MET",
    #"BY_VEGF",
    #"BY_TGF_BETA",
    #"KEGG_APOPTOSIS",
    "KEGG_JAK_STAT_SIGNALING_PATHWAY",
    #"KEGG_MAPK_SIGNALING_PATHWAY",
    "KEGG_MTOR_SIGNALING_PATHWAY",
    "KEGG_TGF_BETA_SIGNALING_PATHWAY",
    #"KEGG_VEGF_SIGNALING_PATHWAY",
    "KEGG_WNT_SIGNALING_PATHWAY",
    "PID_AP1_PATHWAY",
    "PID_FAS_PATHWAY",
    "PID_FGF_PATHWAY",
    "PID_HIF1A_PATHWAY",
    "PID_IL8_CXCR1_PATHWAY",
    "PID_MET_PATHWAY",
    "PID_NFKAPPAB_CANONICAL_PATHWAY",
    "PID_PDGFRA_PATHWAY",
    "PID_PI3KCI_AKT_PATHWAY"
    #"PID_TRAIL_PATHWAY"
    #"KEGG_ADHER",
    #"KEGG_CELL_ADHESION_MOLECULES_CAM",
    #"KEGG_ERBB",
    #"KEGG_MAPK",
    #"KEGG_FOCAL_ADHESION",
    #"GO_CELL_CELL_JUNCTION",
    #"HALLMARK"
    )

  store <- 0
  for (i in 1:length(gs.kw)) {
    temp <- str_subset(names(gene_sets), gs.kw[i])
    store <- c(store, temp)
  }
  ## Remove gene sets that we don't want:
  rem_patterns <- "SPERM|ADIPO|MYO|ALLOGRAFT|PANCREAS|CHOLESTEROL|ACID|CANCER|INTERFERON|APICAL|ESTROGEN|GLYCOLYSIS|UV|KRAS|COMPLEMENT|COAGULATION|UNFOLDED|PEROXISOME|E2F|CHECKPOINT|MYC|DNA|OXIDATIVE|OXYGEN|ANDROGEN|APOPTOSIS|HEME|XENO|MITOTIC"
  
  # rem_patterns <- "SPERM|ADIPO|MYO|ALLOGRAFT|PANCREAS|CHOLESTEROL|ACID"
  store <- store[!grepl(rem_patterns, store)]
  

  ## Pull the gene sets we want:
  gene.sets <- store[-1] %>% 
    na.omit() %>% 
    match(names(gene_sets)) %>% 
    na.omit() %>% 
    gene_sets[.]
    
  ### Calculate GSVA enrichment scores:
  tn.gsva <- gsva(
    data_for_gsva, 
    gene.sets, 
    method="gsva", 
    parallel.sz=detectCores()-1
    )
  tn.gsva.df <- tn.gsva %>% data.frame(gene.set=rownames(.), .) # Convert to data frame
  tn.gsva.df$gene.set <- gsub(".*HALLMARK_|.*REACTOME_|.*PID_", "", tn.gsva.df$gene.set) #Unused: .*KEGG_|
  rownames(tn.gsva.df) <- tn.gsva.df$gene.set
  rm(tn.gsva) # Remove matrix form from environment
}
```

Now, let's visualize the results from GSVA.

```{r Visualize GSVA Results, message=FALSE, warning=FALSE}
#### Visualize with heatmaply:
## Load packages:
library(heatmaply)

## Set color scheme for heat map:
mycol <- brewer.pal(n=11, name="RdBu") %>% rev() # Color scheme for heatmap
#mycol <- colorRampPalette(c("#0000cc","#cccccc","#ff0000")) # Custom color scheme

## Get data to plot for heatmap:
plotdata <- tn.gsva.df[,-1] %>% data.matrix()
rownames(plotdata) <- rownames(tn.gsva.df)
#aheatmap(plotdata)
### Get BCAR3 mRNA expression to possibly append to plotdata:
# scale_fun <- function(x){x/(max(abs(x)))}
# plotdata <- match(colnames(plotdata), tcl.ccle.rna$Cell.line) %>% rbind(plotdata, norm_BCAR3_mRNA = tcl.ccle.rna$BCAR3[.]) %>% .[-1,]
# plotdata["norm_BCAR3_mRNA",] <- plotdata["norm_BCAR3_mRNA",] %>% scale() %>% scale_fun()

## Match BCAR3 expression data to cell lines and format correctly to append to GSVA data above, if we want to:
#b3.data_for_heatmap <- match(colnames(plotdata), tcl.ccle.rna$Cell.line) %>% tcl.ccle.rna$BCAR3[.] %>%  t() %>% data.frame()
#colnames(b3.data_for_heatmap) <- colnames(plotdata)

### Generate heatmap:
nk_col <- 4
hm <- 
heatmaply(
  # plotdata[1:40,],
  plotdata,
  k_col = nk_col, # How many column dendrogram clusters to color
  k_row = 8, # How many row dendrogram clusters to color
  limits = c(-max(abs(plotdata)),max(abs(plotdata))),
  #distfun_row = function(x) as.dist(1-cor(t(x), method = "spearman")),
  #distfun_col = function(x) as.dist(1-cor(x, method = "spearman")),
  # dist_method = "manhattan", # If NULL, Euclidean is used
  hclust_method = NA,
  # show_dendrogram = c(TRUE, FALSE),
  # show_dendrogram = c(FALSE, TRUE),
  show_dendrogram = c(TRUE, TRUE),
  branches_lwd = 0.3,
  colors=mycol,
  # scale = "row",
  # scale = "col",
  key.title="GSVA \nEnrichment Score",
  # showticklabels = c(FALSE, TRUE),
  # showticklabels = c(TRUE, FALSE),
  showticklabels = c(TRUE, TRUE),
  cexCol = 0.5, # Scale size of column tick/label text
  cexRow = 1, # Scale size of row tick/label text
  column_text_angle = 90,
  # ylab = "Sample",
  # xlab = "Sample",
  xlab = "TCGA Sample",
  main = "GSVA of RNA-seq Data",
  # file = "GSVA_CCLE_RNAseq_TNBC.html", # Save the heatmap to html
  )
hm
```
