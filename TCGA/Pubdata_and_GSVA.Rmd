---
title: "Loading publicly available datasets and running GSVA on RNA-seq data"
output: 
  html_document: 
    fig_height: 8
    fig_width: 18
    theme: spacelab
    toc: yes
Author: Paul J. Myers
Date of creation: 3/06/2020
R version: 3.6.2
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

# Housekeeping Code
We load the desired libraries for this script and clear the R workspace.

```{r  Load packages,message=FALSE}
### Load packages:
library(tidyverse)
library(reshape2)
library(ggthemes)
library(ggpubr)
library(pls)
library(cowplot)
library(plotly)
library(RColorBrewer)
library(colorspace)
```

```{r Clear environment}
### Clear R workspace:
rm(list=ls())
```

```{r Check and set working directory}
### Check current working directory:
cwd <- getwd()
cwd
### Set working directory:
# setwd(cwd) # Set current working directory to location of this notebook for easier handling and saving of data associated with the notebook
```

# Load CCLE RNA-seq Data
We now load RNA-seq data from the Cancer Cell Line Encyclopedia (CCLE). (See https://depmap.org/portal/download/ and download the file "CCLE_expression.csv".) We are only interested in using the RNA-seq data for protein coding genes. Other data from the CCLE, including the CCLE's RPPA data and information on all of the cell lines in the CCLE (required for the code below) are also available for download from this portal. These data are supplied as log2-transformed, 1-shifted RSEM TPM values, denoted below as $x_{i,j}^{log}$:

$$x_{i,j}^{log}=log_2(TPM_{i,j}+1)$$
We'll start by first loading the information on all 26 triple-negative breast cancer (TNBC) cell lines that are in the CCLE and then loading the TNBC RNA-seq data itself.

```{r Load CCLE cell line info, warning=FALSE}
##### Load cell line info:
## Path for cell line info:
fn.cells <- "CCLE_sample_info.csv"

## Load info for TNBC cell lines:
cl.sum <- read.csv(fn.cells)   #Cell line summaries
cl.id <- cl.sum$DepMap_ID %>% as.character()  #DepMap IDs for cell lines
cl.name <- cl.sum$stripped_cell_line_name %>% as.character()  #Cell line names
ccle.names <- cl.sum$CCLE_Name %>% as.character() #CCLE cell line names

# Desired TNBC cell lines:
tcl.names <- c("BT20","BT549","CAL120","CAL148","CAL51","CAL851","DU4475","HCC1143","HCC1187",
               "HCC1395","HCC1500","HCC1599","HCC1806","HCC1937","HCC2157","HCC38","HCC70","HDQP1",
               "HMEL","HS274T","HS578T","MDAMB157","MDAMB231","MDAMB436","MDAMB453","MDAMB468","SUM159PT") 

tcl.ind <- which(cl.name %in% tcl.names) #Indices of TNBC lines in full list of cell lines

## Extract TNBC cell line names:
tcl.id <- cl.id[tcl.ind] #TNBC cell line DepMap IDs...
tcl.name <- cl.name[tcl.ind] %>% as.character() #...and the full cell line names in the same order.
tcl.ccle.names <- ccle.names[tcl.ind] # CCLE names for TNBC lines
```

And now load the CCLE RNA-seq data.

```{r Load CCLE RNA-seq data, warning=FALSE}
##### Load CCLE RNA-seq data: log2(TPM+1) values
## File path for CCLE RNA-seq data:
fn4 = "CCLE_RNAseq_gene_expression_TPM_log2.csv"

## Load CCLE RNA-seq data:
ccle.rna <- read_csv(fn4, col_names=T)
ccle.genes <- colnames(ccle.rna)[-1] %>%
  gsub("\\ .*","",.) # Remove extraneous suffixes on gene names
colnames(ccle.rna) <- c("Cell.line", ccle.genes)

## Get TNBC cell line data:
ccle.id.rna <- ccle.rna$Cell.line %>% as.character() # Get DepMap IDs from CCLE data

# Pull out the TNBC IDs, names, and data:
tcl.ind.ccle.rna <- which(ccle.id.rna %in% tcl.id) # Match TNBC cell line DepMap IDs to DepMap IDs in data set
tcl.id.ccle.rna <- ccle.id.rna[tcl.ind.ccle.rna] # DepMap IDs in data set
tcl.name.ccle.rna <- match(tcl.id.ccle.rna, tcl.id) %>%
  tcl.name[.] # Names

# Pull out the TNBC data:
tcl.ccle.rna <- ccle.rna[tcl.ind.ccle.rna,] # mRNA expression

tcl.ccle.rna$Cell.line <- tcl.name.ccle.rna # Replace DepMap IDs with stripped cell line names
```

### RPPA Data
Reverse-phase protein array (RPPA) data from the CCLE can also be obtained from either the primary CCLE website or from the DepMap Portal.

```{r Load CCLE RPPA data}
##### Load CCLE RPPA data: 
## File path for CCLE RPPA data:
fn5 = "CCLE_RPPA_20181003.csv"

## Load CCLE RPPA data:
ccle.rppa <- read_csv(fn5, col_names=T)
ccle.ans <- colnames(ccle.rppa)[-1] %>% 
  gsub("\\_Caution.*","",.) # Remove extraneous "_Caution" suffixes on analyte names
colnames(ccle.rppa) <- c("Cell.line", ccle.ans)


## Get TNBC cell line data:
ccle.names.rppa <- ccle.rppa$Cell.line %>% as.character() # Get CCLE names from CCLE RPPA data

# Pull out the TNBC IDs, names, and data:
tcl.ind.ccle.rppa <- which(ccle.names.rppa %in% tcl.ccle.names) # Match TNBC cell line DepMap IDs to DepMap IDs in data set
tcl.names.ccle.rppa <- ccle.names.rppa[tcl.ind.ccle.rppa] %>% 
  gsub("\\_.*","",.) # Cleaned (stripped) CCLE cell line names


# Pull out the TNBC data:
tcl.ccle.rppa <- ccle.rppa[tcl.ind.ccle.rppa,] # Data

tcl.ccle.rppa$Cell.line <- tcl.names.ccle.rppa # Replace DepMap IDs with stripped cell line names

## Explore the data with ggplot:
ggplot(data = tcl.ccle.rppa) + 
  geom_col(
    fill="#FF6666", # Manually set fill (color) of bars
    color="black", # Bar outline color
    aes(
      x=Cell.line,
      y=EGFR # Select analyte to visualize
      )
    ) +
  geom_hline(yintercept=0)+
  theme_cowplot()+
  theme(
    axis.text.x=element_text(
      angle=45,
      hjust=1
      )
    ) +
  labs(x="Cell line",
       title="CCLE RPPA Data")
```

## MCLP RPPA Data
RPPA data can also be obtained from the MD Anderson Cell Lines Project (MCLP). These data are available at https://tcpaportal.org/mclp/#/download. 

```{r Load MCLP RPPA data}
##### Load MCLP RPPA data: 
## File path for MCLP RPPA data:
fn6 = "MCLP-v1.1-Level4.tsv"

## Load MCLP RPPA data:
mclp.rppa <- read_tsv(fn6, col_names=T)
mclp.ans <- colnames(mclp.rppa)[-1] 
colnames(mclp.rppa)[1] <- "Cell.line"


## Get TNBC cell line data:
mclp.names.rppa <- mclp.rppa$Cell.line %>% as.character() # Get MCLP names from MCLP RPPA data

# Pull out the TNBC IDs, names, and data:
tcl.ind.mclp.rppa <- which(mclp.names.rppa %in% tcl.names) # Match TNBC cell line names in data set
tcl.names.mclp.rppa <- mclp.names.rppa[tcl.ind.mclp.rppa] %>% 
  gsub("\\_.*","",.) # MCLP cell line names


# Pull out the TNBC data:
tcl.mclp.rppa <- mclp.rppa[tcl.ind.mclp.rppa,] # Data

## Explore the data with ggplot:
ggplot(data = tcl.mclp.rppa) + 
  geom_col(
    fill="#FF6666", # Manually set fill (color) of bars
    color="black", # Bar outline color
    aes(
      x=Cell.line,
      y=EGFR # Select analyte to visualize
      )
    ) +
  geom_hline(yintercept=0)+
  theme_cowplot()+
  theme(
    axis.text.x=element_text(angle=45,
                             hjust=1)) +
  labs(x="Cell line",
       title="MCLP RPPA Data")
```

## TCGA RNA-seq and RPPA Data
### RNA-seq Data
RNA-seq data from The Cancer Genome Atlas (TCGA) can be obtained in multiple ways from multiple sources. The data used below, which only contains RNA-seq data for TCGA samples identified pathologically as triple-negative breast cancer, were originally obtained by the lab of Kevin A. James and were supplied as unnormalized RSEM values. The easiest way to obtain TCGA data is through the UCSC Xena portal at https://xena.ucsc.edu/public/ and https://xenabrowser.net/. The Xena portal also provides access to additional tissue sample and cell line repositories (including the CCLE) besides TCGA alone.

Below, we load TCGA RNA-seq data from TNBC tissue samples and normalize the RSEM values as described above for the CCLE RNA-seq data.
```{r Load TCGA TNBC RNA-seq data}
##### Load TCGA TNBC RNA-seq data (obtained from Kevin Janes as unnormalized RSEM values and already selected as TN based on pathology): 
## File path for TCGA data:
fn7 = "TCGA_TNBC_RNAseq.txt"

## Load TCGA data:
tcga <- read_tsv(fn7, col_names=T)

tcga$Gene_ID <- tcga$Gene_ID %>% # Get gene names
  gsub("\\|.*","",.) # Remove extraneous gene name suffixes


tcga.tnbc.samps <- colnames(tcga)[-1] # Store original TCGA TNBC sample names
tcga.samps <- tcga.tnbc.samps %>% # Get sample names to clean them up (for readability on plots)
  gsub("\\TCGA-*|\\-01*","",.) #Remove extraneous text from names

tcga <- tcga[!tcga$Gene_ID=="?",]  # Remove "?" genes

tcga.genes <- tcga$Gene_ID # Get gene names

## Need to transpose matrix and normalize RSEM values as TPM (transcripts per million):
tcga.1 <- tcga[,-1] %>% # Get just numeric entries (ignore Gene_ID)
  data.matrix() %>% # Convert to numeric matrix
  scale(center=F, scale=colSums(.)) %>% # Divide columns by sums
  multiply_by(1.0e6) %>% # Multiply by one million (now have TPM)
  t() %>%  # Transpose
  add(1) %>% # Shift by 1 (for taking log-transform of zero values)
  log2() %>%  # log2 transform
  data.frame() # Convert back to data frame
  
colnames(tcga.1) <- tcga.genes # Rename columns w/ gene names
tcga.2 <- tcga.1 %>% data.frame(tcga.samps, .) # Append sample names as a variable
colnames(tcga.2)[1] <- "Sample" # Rename sample column


##### Explore data with ggplot:
##### Plot mRNA expression ##### 
#### Column plot RNA expression
ggplot(data = tcga.2) + 
  geom_col(
    fill="#FF6666", # Manually set fill (color) of bars
    color="black", # Bar outline color
    aes(
      x=Sample,
      y=BCAR3 # Select analyte to visualize
      )
    ) +
  theme_cowplot()+
  # theme_base()+
  scale_y_continuous(
    # don't expand y scale at the lower end
    expand = expand_scale(mult = c(0, 0.05))
  ) +  
  theme(
    axis.text.x=element_text(
      size=10, # Size of X tick labels
      angle=90, # Angle of X tick labels
      vjust=0.4
      )
    ) + # Adjust X tick horizontal positions
  labs(fill="Gene",
       x="Cell line",
       title=expression(paste("TCGA RNA-seq: ", log[2],"(TPM+1)")))
##### Two-gene scatterplot #####
#### Scatter plot of two genes with simple linear model line and confidence intervals
ggplot(data=tcga.2, 
       aes(
         x=EGFR,
         y=BCAR3)
       )+
  geom_smooth(method="lm")+
  geom_point()+ # 2D scatter plot
  # geom_label(
  #   aes(
  #   label=Sample
  #   ), # Add sample names to plot (if desired)
  #   nudge_y=0.2,
  #   size = 3
  #   )+
  theme_cowplot()+
  theme(
    axis.text.x=element_text(
      size=11, # Size of X tick labels
      # angle=90, # Angle of X tick labels
      vjust=0.4
      )
    ) + # Adjust X tick horizontal positions
  labs(
    fill="Gene",
    title=expression(paste("TCGA RNA-seq: ", log[2],"(TPM+1)"))
    )


## Remove extraneous variables from memory, if desired:
rm(tcga, tcga.1)
```
### RPPA Data
Load the TCGA BRCA RPPA data (obtained from UCSC Xena portal). For consistency's sake with the MCLP data, we're going to use the "replicate-based normalization" (RBN) data.
```{r Load TCGA BRCA RPPA data}
## File path for data:
fn8 <- "TCGA_BRCA_RPPA_RBN.tsv"
## Load file:
brca.tcga.rppa <- read_tsv(fn8, col_names = T)
## Store sample names and extract names of known TNBC TCGA samples:
match.tcga.samps <- colnames(brca.tcga.rppa) %>% # Get RPPA sample names
  match(tcga.tnbc.samps) %>% # Match RPPA samples to TNBC RNA-seq samples
  tcga.tnbc.samps[.] %>% # Get TN RPPA sample names 
  na.omit() # Remove non-TN samples
# view(match.tcga.samps)
## Clean the sample names:
tcga.rppa.samps <- match.tcga.samps %>% # Get sample names to clean them up (for readability on plots)
  gsub("\\TCGA-*|\\-01*","",.) # Remove extraneous text from names

## Get TNBC sample RPPA data:
tcl.tcga.rppa <- brca.tcga.rppa[,match.tcga.samps] %>% 
  data.matrix() %>% # Convert to numeric
  t() %>% # Transpose
  data.table(Sample=tcga.rppa.samps, .) # Convert to data.table (more efficient data.frame)
colnames(tcl.tcga.rppa)[-1] <- brca.tcga.rppa$Sample_description # Add analyte (column/variable) names

##### Explore data with ggplot:
##### Heatmap of RPPA scores #####
## Melt data to long format:
tcl.tcga.rppa.l <- tcl.tcga.rppa %>%
  melt(id.vars="Sample")

## Plot as a heatmap:
ggplot(data=tcl.tcga.rppa.l) +
  geom_tile( # Use tile geom --> basically a heatmap
    # linetype="dashed", # Type of lines between tiles
    # color="#000000", # Color of lines between tiles
    aes(
      fill=value,
      x=variable,
      y=Sample
    )
  )+
  # scale_fill_viridis_c(
  #   limits = c(-max(tcl.tcga.rppa.l$value),max(tcl.tcga.rppa.l$value))
  #   )+ # Viridis color scheme
  scale_fill_gradient2( # Custom color gradient for bars
    limits = c(-max(tcl.tcga.rppa.l$value),max(tcl.tcga.rppa.l$value)),
    midpoint=0,
    low="#003366",
    mid="#CCCCCC",
    high="red",
    space ="Lab"
    ) +
  theme_cowplot(
    ) +
  theme(
    axis.text.x=element_text(
      size = 10,  # X tick mark TEXT SIZE
      angle = 90, # X tick mark ANGLE
      hjust = 1, # Shift horizontal position of X tick marks
      vjust = 0.4 # Shift vertical position of X tick marks
    )
  ) +
  scale_y_discrete(
    # don't expand y scale at the lower end
    expand = expand_scale(mult = c(0, 0))
  ) +
  labs(
    title="TCGA TNBC RPPA",
    x="Analyte",
    y="Sample",
    fill="RPPA score"
  ) + 
  guides(
    # fill=FALSE
  )
```

## GSVA: CCLE RNA-seq Data
### mRNA Expression Data
Here, we'll use the technique known as gene set variation analysis (GSVA) to analyze the molecular/cellular signaling pathways that are up- and down-regulated in each of the TNBC cell lines of interest. GSVA is closely related to single-sample gene set enrichment analysis (ssGSEA). The GSVA package we'll use below actually includes an option for running ssGSEA in the main command for the analysis, if it's desired.

The description for the GSVA R package can be found [here](https://www.bioconductor.org/packages/release/bioc/html/GSVA.html). 
```{r GSVA: CCLE RNA-seq data, warning=FALSE, message=FALSE}
### Install packages if not done already:
# BiocManager::install(c("limma","GSVA","GSVAdata","org.Hs.eg.db","GSEABase","snow","rlecuyer","edgeR")) # Comment out this line if you've already installed these packages to your current R distribution.

### Load packages:
library(GSVA) # Gene set variation analysis package from Bioconductor --> This package contains a command that can perform four types of gene set enrichment analyses: GSVA, ssGSEA, PLAGE, and z-score.
library(GSVAdata)
library(org.Hs.eg.db)
library(GSEABase)
library(limma)
library(msigdbr)

### Start by putting data in .GCT format:
data_for_gsva <- tcl.ccle.rna %>% as.matrix() %>% t() %>% .[-1,]
colnames(data_for_gsva) <- tcl.ccle.rna$Cell.line

## Convert gene names to Entrez IDs:
entrez_ids <- rownames(data_for_gsva) %>% mapIds(org.Hs.eg.db, ., 'ENTREZID', 'SYMBOL')
rownames(data_for_gsva) <- entrez_ids

### Define MSigDB gene set collection to use:
gene_sets <- getGmt("msigdb.v7.0.entrez.gmt") %>% # Load all GSEA/Broad MSigDB gene sets
  .[grep("^HALLMARK|^KEGG|^CELL_|^REACTOME_SIGNALING_BY|^PID_", names(.))] # Pull curated gene sets by their database/primary identifier

### GO gene sets:
library(gage) # Install using Bioconductor if you don't have it

### Select subset of gene sets to analyze using keywords in their names:
## Gene set keywords:
## Use GO gene sets or MSigDB gene sets?
gene_set_choice <- "MSigDB" # Define this as either "GO" or something completely different (like "MSigDB") --> if "GO" is not used, then key words for MSigDB gene sets will be chosen automatically for the GSVA analysis below

### Load desired gene set(s) and perform GSVA:
if(gene_set_choice == "GO"){
  ### Calculate GSVA enrichment scores:
  tn.gsva <- gsva(
    data_for_gsva, 
    go.gsets()[["go.sets"]], 
    method="gsva", 
    parallel.sz=detectCores()-1
    )
  tn.gsva.df <- tn.gsva %>% data.frame(gene.set=rownames(.), .) # Convert to data frame
  rm(tn.gsva) # Remove matrix form from environment
  
} else {
  ## Select key words to further subset the selected MSigDB gene set collection:
  gs.kw <- c(
    # "REACTOME",
    # "BREAST",
    "RECEPTOR_TYROSINE",
    "BY_EGFR",
    # "BY_ERBB2",
    # "BY_ERBB4",
    "PID_ERBB2_ERBB3",
    "PID_ERBB_NETWORK",
    "PID_ECADHERIN_STAB",
    "PID_TGBFR",
    "BY_MET",
    "BY_VEGF",
    "BY_TGF_BETA",
    "KEGG_ADHER",
    "KEGG_CELL_ADHESION_MOLECULES_CAM",
    "KEGG_ERBB",
    "KEGG_MAPK",
    "KEGG_FOCAL_ADHESION",
    "GO_CELL_CELL_JUNCTION",
    "HALLMARK"
    )

  store <- 0
  for (i in 1:length(gs.kw)) {
    temp <- str_subset(names(gene_sets), gs.kw[i])
    store <- c(store, temp)
  }
  ## Remove gene sets that we don't want:
  rem_patterns <- "SPERM|ADIPO|MYO|ALLOGRAFT|PANCREAS|CHOLESTEROL|ACID|CANCER|INTERFERON|APICAL|ESTROGEN|GLYCOLYSIS|UV|KRAS|COMPLEMENT|COAGULATION|UNFOLDED|PEROXISOME|E2F|CHECKPOINT|MYC|DNA|OXIDATIVE|OXYGEN|ANDROGEN|APOPTOSIS|HEME|XENO|MITOTIC"
  
  # rem_patterns <- "SPERM|ADIPO|MYO|ALLOGRAFT|PANCREAS|CHOLESTEROL|ACID"
  store <- store[!grepl(rem_patterns, store)]
  

  ## Pull the gene sets we want:
  gene.sets <- store[-1] %>% 
    na.omit() %>% 
    match(names(gene_sets)) %>% 
    na.omit() %>% 
    gene_sets[.]
    
  ### Calculate GSVA enrichment scores:
  tn.gsva <- gsva(
    data_for_gsva, 
    gene.sets, 
    method="gsva", 
    parallel.sz=detectCores()-1
    )
  tn.gsva.df <- tn.gsva %>% data.frame(gene.set=rownames(.), .) # Convert to data frame
  tn.gsva.df$gene.set <- gsub(".*HALLMARK_|.*REACTOME_|.*PID_", "", tn.gsva.df$gene.set) #Unused: .*KEGG_|
  rownames(tn.gsva.df) <- tn.gsva.df$gene.set
  rm(tn.gsva) # Remove matrix form from environment
}
```

Now, let's visualize the results from GSVA.

```{r Visualize GSVA Results, message=FALSE, warning=FALSE}
#### Visualize with heatmaply:
## Load packages:
library(heatmaply)

## Set color scheme for heat map:
mycol <- brewer.pal(n=11, name="RdBu") %>% rev() # Color scheme for heatmap
# mycol <- colorRampPalette(c("#0000cc","#cccccc","#ff0000")) # Custom color scheme

## Get data to plot for heatmap:
plotdata <- tn.gsva.df[,-1] %>% data.matrix()
rownames(plotdata) <- rownames(tn.gsva.df)

### Get BCAR3 mRNA expression to possibly append to plotdata:
# scale_fun <- function(x){x/(max(abs(x)))}
# plotdata <- match(colnames(plotdata), tcl.ccle.rna$Cell.line) %>% rbind(plotdata, norm_BCAR3_mRNA = tcl.ccle.rna$BCAR3[.]) %>% .[-1,]
# plotdata["norm_BCAR3_mRNA",] <- plotdata["norm_BCAR3_mRNA",] %>% scale() %>% scale_fun()

## Match BCAR3 expression data to cell lines and format correctly to append to GSVA data above, if we want to:
b3.data_for_heatmap <- match(colnames(plotdata), tcl.ccle.rna$Cell.line) %>% tcl.ccle.rna$BCAR3[.] %>%  t() %>% data.frame()
colnames(b3.data_for_heatmap) <- colnames(plotdata)

### Generate heatmap:
nk_col <- 4
hm <- 
heatmaply(
  # plotdata[1:40,],
  plotdata,
  k_col = nk_col, # How many column dendrogram clusters to color
  k_row = 8, # How many row dendrogram clusters to color
  limits = c(-max(abs(plotdata)),max(abs(plotdata))),
  distfun_row = function(x) as.dist(1-cor(t(x), method = "spearman")),
  distfun_col = function(x) as.dist(1-cor(x, method = "spearman")),
  # dist_method = "manhattan", # If NULL, Euclidean is used
  hclust_method = NA,
  # show_dendrogram = c(TRUE, FALSE),
  # show_dendrogram = c(FALSE, TRUE),
  show_dendrogram = c(TRUE, TRUE),
  branches_lwd = 0.3,
  colors=mycol,
  # scale = "row",
  # scale = "col",
  key.title="GSVA \nEnrichment Score",
  # showticklabels = c(FALSE, TRUE),
  # showticklabels = c(TRUE, FALSE),
  showticklabels = c(TRUE, TRUE),
  cexCol = 1, # Scale size of column tick/label text
  cexRow = 1, # Scale size of row tick/label text
  column_text_angle = 90,
  # ylab = "Sample",
  # xlab = "Sample",
  xlab = "Triple-negative cell line",
  main = "GSVA of CCLE RNA-seq Data",
  # file = "GSVA_CCLE_RNAseq_TNBC.html", # Save the heatmap to html
  )
hm
```

```{r Plot BCAR3 mRNA in same order as heatmap clusters}
## Get dendrogram from heatmap
dend <- hclust(as.dist(1-cor(plotdata, method = "spearman")), method = "ward.D2") %>% # Get dendrogram groups calculated in the heatmaply call above
  cutree(dend, k = nk_col) %>% as.matrix()
dend <- data.frame(dend, variable = rownames(dend))# %>% as.character()

## Get order of clustered samples:
cell_order <- hm[["x"]][["layout"]][["xaxis"]][["ticktext"]]

### Generate a column chart of BCAR3 expression and combine it with the heatmaply object:
## Format BCAR3 mRNA data to match order from heatmap:
b3.data_for_heatmap.l <- b3.data_for_heatmap %>% as.matrix() %>% t() %>% scale() %>% data.frame(variable = rownames(.),value = .)
b3.data_for_heatmap.l <- b3.data_for_heatmap.l %>% full_join(dend)
b3.data_for_heatmap.l$dend <- b3.data_for_heatmap.l$dend %>% factor(levels = c(3,2,4,1))
b3.data_for_heatmap.l$variable <- b3.data_for_heatmap.l$variable %>% factor(levels = cell_order)


# b3mrna_plot <- 
ggplot(data = b3.data_for_heatmap.l) + 
  geom_col(
    # fill="#FF6666", # Manually set fill (color) of bars
    color="black", # Bar outline color
    aes(x = variable, y = value,
        fill = value,
        )
    ) +
  theme_cowplot(16) + 
  scale_y_continuous(
    # limits = c(0,0.5),
    # don't expand y scale at the lower end
    # expand = expand_scale(mult = c(0, 0.05))
  ) +
  theme(
    axis.text.x=element_text(
      size=12, # Size of X tick labels
      angle= 60, # Angle of X tick labels
      hjust = 1, # Adjust X tick horizontal positions
      # vjust=0.4
      )
    ) +  
  # scale_fill_discrete() +
  scale_fill_continuous_diverging("Blue-Red 3") +
  labs(
    title = "BCAR3 mRNA expression",
    # x = "",
    x = "Cell line",
    # y = expression(paste(log[2],"(TPM+1)")) # Comment out this line if using ggplotly to make plotly version of this chart
    # y = "log2(TPM+1)"
    y = "z-score"
  ) +
  guides(
    fill = FALSE
  )
  
# b3mrna_plotly <- ggplotly(p=b3mrna_plot)
# # b3mrna_plotly
# 
# subplot(b3mrna_plotly, hm,
#         nrows = 1)
```

```{r BCAR3 mutual information to GSVA enrichment scores, warning=FALSE, message=FALSE}
#### Mutual information: 
## Load packages:
library(infotheo)

## Discretize data for MI:
b3.mi_data <- full_join(plotdata %>% data.frame(), b3.data_for_heatmap %>% data.frame()) %>% t()
colnames(b3.mi_data) <- c(rownames(plotdata), "BCAR3_mRNA")
disc.b3 <- discretize(b3.mi_data, disc = "equalfreq")#, nbins = 5)
disc.nob3 <- disc.b3[, -which(colnames(disc.b3) == "BCAR3_mRNA")]

### Calculate mutual information:
b3.mi <- matrix(data = 0, nrow = ncol(disc.nob3), ncol = 1)

for(i in 1:ncol(disc.nob3)){
  temp <- mutinformation(disc.b3[,"BCAR3_mRNA"], disc.nob3[,i], method = "emp")
  # temp <- temp %>% natstobits() # Convert MI from nats to bits (natural log to log-2)
  b3.mi[i,1] <- temp
}
rownames(b3.mi) <- colnames(disc.nob3)

b3.mutinf <- data.frame(gene.set = colnames(disc.nob3), mi=b3.mi) 
b3.mutinf$gene.set <- gsub(".*HALLMARK_", "", b3.mutinf$gene.set) 
b3.mutinf <- b3.mutinf %>% .[order(.$mi, decreasing=T),]
b3.mutinf$gene.set <- factor(b3.mutinf$gene.set, levels=b3.mutinf$gene.set)

### Spearman's Rs:
b3.rs <- cor(b3.mi_data[,"BCAR3_mRNA"], b3.mi_data[,-which(colnames(disc.b3) == "BCAR3_mRNA")], method = "spearman") %>% 
  t() %>% 
  data.frame(gene.set = colnames(disc.nob3), mi = .) 
b3.rs$gene.set <- gsub(".*HALLMARK_|.*REACTOME_|.*KEGG_", "", b3.rs$gene.set) 
b3.rs <- b3.rs %>%  .[order(.$mi, decreasing=T),]
b3.rs$gene.set <- factor(b3.rs$gene.set, levels=b3.rs$gene.set)

#### Plots:
ptsize <- 6
ptshape <- 21
lnsz <- 1.2
txtsz <- 4

### Plot mutual information:
# mi.plot <-
ggplot(
  data = b3.mutinf,
  aes(
    x = gene.set,
    y = mi,
    group = 1,
    label = gene.set,
    # label = mi %>% round(2),
    # color = mi,
    )
  ) + 
  # geom_segment(aes(x = gene.set, y = 0, xend = gene.set, yend = mi),
  #              color = "grey",
  #              ) +
  geom_hline(yintercept = 0, color = "#999999") +
  geom_line(size = lnsz, color = "red") +
  geom_point(shape = ptshape, size = ptsize, fill = "#999999", color = "black") +
  # geom_col(color = "#333333") +
  geom_text(
    angle = 90,
    nudge_y = 0.01,
    hjust = 0,
    size = txtsz
    ) +
  theme_cowplot(
    18,
    line_size = lnsz
  ) + 
    # theme_minimal_vgrid()+
  scale_y_continuous(
    limits = c(NA, 0.7),
    # don't expand y scale at the lower end
    expand = expand_scale(mult = c(0, 0.05))
  ) +
  theme(
    axis.text.x = element_blank()
    # axis.text.x=element_text(
    #   size=12, # Size of X tick labels
    #   angle= 75, # Angle of X tick labels
    #   hjust = 1, # Adjust X tick horizontal positions
    #   # vjust=0.4
    #   )
    ) +
  labs(
    title = "GSVA ES mutual information to BCAR3 mRNA expression (27 TNBC cell lines)",
    x = "Gene set",
    y = "Mutual information (nats)"
  )
# ggplotly(mi.plot)

### Plot Spearman's Rs:
# rs.plot <- 
ggplot(
  data = b3.rs,
  aes(
    x = gene.set,
    y = mi,
    group = 1,
    label = gene.set,
    # label = mi %>% round(2),
    # color = mi,
    )
  ) + 
  # geom_segment(aes(x = gene.set, y = 0, xend = gene.set, yend = mi),
  #              color = "grey",
  #              ) +
  geom_hline(yintercept = 0, color = "#999999") +
  geom_line(size = lnsz, color = "red") +
  geom_point(shape = ptshape, size = ptsize, fill = "#999999", color = "black") +
  # geom_col(color = "#333333") +
  geom_text(
    angle = 90,
    nudge_y = 0.02,
    hjust = 0,
    size = txtsz
    ) +
  theme_cowplot(
    18,
    line_size = lnsz
  ) + 
    # theme_minimal_vgrid()+
  scale_y_continuous(
    limits = c(-0.5, 1.5),
    # don't expand y scale at the lower end
    expand = expand_scale(mult = c(0, 0.05))
  ) +
  theme(
    axis.text.x = element_blank()
    # axis.text.x=element_text(
    #   size=12, # Size of X tick labels
    #   angle= 75, # Angle of X tick labels
    #   hjust = 1, # Adjust X tick horizontal positions
    #   # vjust=0.4
    #   )
    ) +
  labs(
    title = "GSVA enrichment score ranks to BCAR3 mRNA (27 TNBC cell lines)",
    x = "Gene set",
    y = "Spearman's Rs"
  )
```

```{r Check whether BCAR1 and BCAR3 are in selected gene sets, warning=FALSE, message=FALSE}
### Entrez IDs:
bcar.eid <- mapIds(org.Hs.eg.db, c("BCAR1","BCAR3"), 'ENTREZID', 'SYMBOL')

### Find whether BCAR3 and BCAR1 (Cas) are in the selected gene sets:
bcar1.in.gs <- NULL # Initialize vectors of yes/no data --> could probably just set this up as a matrix and loop over columns for each gene
bcar3.in.gs <- NULL
for(i in 1:length(gene.sets)){
  temp.eid <- gene.sets[[i]]@geneIds
  bcar1.in.gs[i] <- which(bcar.eid[1] %in% temp.eid) %>% sum() # BCAR1 (Cas)
  bcar3.in.gs[i] <- which(bcar.eid[2] %in% temp.eid) %>% sum() # BCAR3
}
bcar.gs <- data.frame(gene.set=tn.gsva.df$gene.set, BCAR1 = bcar1.in.gs, BCAR3 = bcar3.in.gs) # Put together in data frame
rownames(bcar.gs) <- tn.gsva.df$gene.set
bcar.gs$BCAR1.yn <- factor(bcar.gs$BCAR1, levels = c(0,1), labels = c("No","Yes"))
bcar.gs$BCAR3.yn <- factor(bcar.gs$BCAR3, levels = c(0,1), labels = c("No","Yes"))

## Reorder the rows of the yes/no data to match the GSVA heatmap:
row_order <- hm[["x"]][["layout"]][["yaxis2"]][["categoryarray"]] #%>% factor(levels = .)
row_order <- row_order %>% factor(levels = row_order)
bcar.gs$gene.set <- bcar.gs$gene.set %>% factor(levels = row_order)
bcar.gs <- bcar.gs[order(bcar.gs$gene.set),]

heatmaply(
  bcar.gs[,c("BCAR1","BCAR3")],
  show_dendrogram = c(FALSE,FALSE),
  hide_colorbar = TRUE,
  col=c("#cc0000","#33cc33"),
  main="Are BCAR1 and BCAR3 in these gene sets?",
  draw_cellnote = TRUE,
  cellnote_textposition = "middle center",
  cellnote_size = 12,
  cellnote = bcar.gs[,c("BCAR1.yn","BCAR3.yn")],
  Rowv = FALSE,
  grid_color = "black",
  column_text_angle = 0,
  fontsize_col = 14,
  )
```